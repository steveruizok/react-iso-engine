{"version":3,"sources":["IsoWorld/Block.ts","IsoWorld/Camera.ts","IsoWorld/utils.ts","state/index.ts","IsoWorld/IsoWorld.ts","IsoWorld/Painter.ts","IsoWorld/index.ts","components/SVGBlock.tsx","components/HoveredIndicator.tsx","components/ZCursorIndicator.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["blockOptions","color","Block","position","size","_this","this","options","arguments","length","undefined","Object","classCallCheck","faces","busy","silhouette","outline","edge","adjacent","north","east","south","west","above","below","blocksBehind","blocksInFront","moveTo","resizeTo","Camera","origin","scale","createClass","key","value","point","x","y","z","h","Math","sqrt","v","isoPoint","isoToScreen","spaceToIso","floor","tHeight","tWidth","block","_block$position","_block$size","minX","maxX","minY","maxY","minZ","maxZ","_this$getIsoVerts","getIsoVerts","frontDown","backUp","leftDown","rightDown","minH","maxH","_block$position2","_block$size2","sx","sy","sz","backDown","rightUp","leftUp","frontUp","verts","getIsoNamedSpaceVerts","keys","reduce","acc","cur","_this2","spaceToScreen","amin","amax","bmin","bmax","block_a","block_b","getIsoSepAxis","getSpaceSepAxis","a","getBounds","b","areRangesDisjoint","getIsoBounds","_ref","range","num","toConsumableArray","Array","map","_","i","pull","array","element","splice","indexOf","toPoint","concat","toPathData","points","close","slice","p","blocks","defaults","width","height","IsoWorld","params","sorted","camera","painter","hovered","selected","cursor","setHovered","animateBlock","property","duration","anime","objectSpread","targets","easing","update","renderBlock","sort","complete","moveBlock","direction","next","nextBlocks","getBlocks","maxBy","assign","getEdge","getFaces","getSilhouette","getOutline","render","sortBlocks","getBlockAtIso","find","px","py","pz","sortBy","filter","_block$position3","setCursor","shape","_params$origin","_params$scale","_params$blocks","Painter","getSorted","isArray","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","done","err","return","j","frontBlock","numBlocks","getFrontBlock","push","blocksToDraw","blocksDrawn","pop","front","forEach","getAdjacentBlocks","_block$position4","getScreenVerts","_block$adjacent","l","r","face","colors","grey","yellow","SVGBlock","_this$props","props","onMouseEnter","onClick","selectedColor","react_default","createElement","ev","faceIndex","fill","d","stroke","strokeWidth","Component","observer","HoveredIndicator","iso","pointerEvents","ZCursorIndicator","zCursor","_iso$camera","transform","textAnchor","fontSize","fontWeight","decorate","observable","addBlocks","action","bound","flat","player","w","App","container","React","createRef","mousePoint","state","showCursor","handleClick","event","pointToIso","createBlock","handleMouseMove","pageX","pageY","buttons","click","_this$state","current","point3","offsetLeft","offsetTop","screenToIso","window","addEventListener","keyHandlers","q","setState","e","s","_this3","_this$state2","blocksToShow","focus","lower","higher","className","ref","style","margin","onMouseLeave","viewBox","left","top","border","onMouseMove","opacity","index","components_SVGBlock","Fragment","components_HoveredIndicator","components_ZCursorIndicator","defaultProps","Boolean","location","hostname","match","ReactDOM","src_App_0","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"4QAGMA,EAAe,CACpBC,MAAO,QAKKC,EAqBZ,SAAAA,EAAYC,EAAkBC,GAAsC,IAAAC,EAAAC,KAAxBC,EAAwBC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAdR,EAAcW,OAAAC,EAAA,EAAAD,CAAAL,KAAAJ,GAAAI,KApBpEL,WAoBoE,EAAAK,KAnBpEO,MAAQ,GAmB4DP,KAlBpEQ,MAAO,EAkB6DR,KAjBpES,WAAa,GAiBuDT,KAhBpEU,QAAU,GAgB0DV,KAfpEW,KAAO,GAe6DX,KAdpEY,SAA2B,CAC1BC,WAAOT,EACPU,UAAMV,EACNW,WAAOX,EACPY,UAAMZ,EACNa,WAAOb,EACPc,WAAOd,GAQ4DJ,KALpEH,cAKoE,EAAAG,KAJpEF,UAIoE,EAAAE,KAHpEmB,aAAwB,GAG4CnB,KAFpEoB,cAAyB,GAE2CpB,KAMpEqB,OAAS,SAACxB,GACTE,EAAKF,SAAWA,GAPmDG,KAUpEsB,SAAW,SAACxB,GACXC,EAAKD,KAAOA,GAVZE,KAAKH,SAAWA,EAChBG,KAAKF,KAAOA,EACZE,KAAKL,MAAQM,EAAQN,OCsBV4B,EAAb,WASC,SAAAA,EAAYC,EAAeC,GAAgBpB,OAAAC,EAAA,EAAAD,CAAAL,KAAAuB,GAAAvB,KAR3CwB,YAQ0C,EAAAxB,KAP1CyB,WAO0C,EACzCzB,KAAKwB,OAASA,EACdxB,KAAKyB,MAAQA,EAXf,OAAApB,OAAAqB,EAAA,EAAArB,CAAAkB,EAAA,EAAAI,IAAA,aAAAC,MAAA,SAmBYC,GAAe,IACnBC,EAAYD,EAAZC,EAAGC,EAASF,EAATE,EAAGC,EAAMH,EAANG,EAKZ,MAAO,CACNF,EAJDA,GAAKE,EAKJD,EAJDA,GAAKC,EAKJC,GAAKH,EAAIC,GAAKG,KAAKC,KAAK,GAAM,EAC9BC,GAAIN,EAAIC,GAAK,KA7BhB,CAAAJ,IAAA,cAAAC,MAAA,SAsCaS,GAAoB,IACvBJ,EAASI,EAATJ,EAAGG,EAAMC,EAAND,EACX,MAAO,CACNN,EAAGG,EAAIjC,KAAKyB,MAAQzB,KAAKwB,OAAOM,EAChCC,GAAIK,EAAIpC,KAAKyB,MAAQzB,KAAKwB,OAAOO,KA1CpC,CAAAJ,IAAA,gBAAAC,MAAA,SAmDeC,GACb,OAAO7B,KAAKsC,YAAYtC,KAAKuC,WAAWV,MApD1C,CAAAF,IAAA,cAAAC,MAAA,SA2DaC,GAAwC,IAAzBW,EAAyBtC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,IAAAA,UAAA,GACnD2B,EAAMC,GAAK9B,KAAKwB,OAAOM,EAAID,EAAMG,EACjCH,EAAME,GAAK/B,KAAKwB,OAAOO,EAAIF,EAAMG,EAEjC,IAAMS,EAAUzC,KAAKyB,MACfiB,EAAsB,MAAb1C,KAAKyB,MAEhBM,IAAMF,EAAMC,GAAKY,EAAS,GAAKb,EAAME,GAAKU,EAAU,IAAM,EAC1DX,IAAMD,EAAME,GAAKU,EAAU,GAAKZ,EAAMC,GAAKY,EAAS,IAAM,EAO9D,OALIF,IACHV,EAAII,KAAKM,MAAMV,GACfC,EAAIG,KAAKM,MAAMT,IAGT,CACND,IACAC,IACAE,IAAMH,EAAIC,GAAKG,KAAKC,KAAK,GAAM,EAC/BC,GAAIN,EAAIC,GAAK,KA9EhB,CAAAJ,IAAA,YAAAC,MAAA,SAsFWe,GAAyB,IAAAC,EAChBD,EAAM9C,SAAlBiC,EAD4Bc,EAC5Bd,EAAGC,EADyBa,EACzBb,EAAGC,EADsBY,EACtBZ,EADsBa,EAGFF,EAAM7C,KACtC,MAAO,CACNgD,KAAMhB,EACNiB,KAAMjB,EAN2Be,EAG1Bf,EAIPkB,KAAMjB,EACNkB,KAAMlB,EAR2Bc,EAGnBd,EAMdmB,KAAMlB,EACNmB,KAAMnB,EAV2Ba,EAGZb,KAzFxB,CAAAL,IAAA,eAAAC,MAAA,SAwGce,GAA4B,IAAAS,EACWpD,KAAKqD,YAAYV,GAA5DW,EADgCF,EAChCE,UAAWC,EADqBH,EACrBG,OAAQC,EADaJ,EACbI,SAAUC,EADGL,EACHK,UAErC,MAAO,CACNX,KAAMQ,EAAUxB,EAChBiB,KAAMQ,EAAOzB,EACbkB,KAAMM,EAAUvB,EAChBkB,KAAMM,EAAOxB,EACb2B,KAAMF,EAASvB,EACf0B,KAAMF,EAAUxB,KAjHnB,CAAAN,IAAA,wBAAAC,MAAA,SA0HuBe,GAAwB,IAAAiB,EAC3BjB,EAAM9C,SAAlBiC,EADuC8B,EACvC9B,EAAGC,EADoC6B,EACpC7B,EAAGC,EADiC4B,EACjC5B,EADiC6B,EAEblB,EAAM7C,KAA3BgE,EAFkCD,EAErC/B,EAAUiC,EAF2BF,EAE9B9B,EAAUiC,EAFoBH,EAEvB7B,EAEtB,MAAO,CACNyB,UAAW,CAAE3B,EAAGA,EAAIgC,EAAI/B,EAAGA,EAAGC,EAAGA,GACjCwB,SAAU,CAAE1B,EAAGA,EAAGC,EAAGA,EAAIgC,EAAI/B,EAAGA,GAChCiC,SAAU,CAAEnC,EAAGA,EAAIgC,EAAI/B,EAAGA,EAAIgC,EAAI/B,EAAGA,GACrCsB,UAAW,CAAExB,EAAGA,EAAGC,EAAGA,EAAGC,EAAGA,GAC5BkC,QAAS,CAAEpC,EAAGA,EAAIgC,EAAI/B,EAAGA,EAAGC,EAAGA,EAAIgC,GACnCG,OAAQ,CAAErC,EAAGA,EAAGC,EAAGA,EAAIgC,EAAI/B,EAAGA,EAAIgC,GAClCT,OAAQ,CAAEzB,EAAGA,EAAIgC,EAAI/B,EAAGA,EAAIgC,EAAI/B,EAAGA,EAAIgC,GACvCI,QAAS,CAAEtC,EAAGA,EAAGC,EAAGA,EAAGC,EAAGA,EAAIgC,MAtIjC,CAAArC,IAAA,cAAAC,MAAA,SA+Iae,GAA2B,IAAA5C,EAAAC,KAChCqE,EAAQrE,KAAKsE,sBAAsB3B,GACzC,OAAOtC,OAAOkE,KAAKF,GAAOG,OACzB,SAACC,EAAeC,GAEf,OADAD,EAAIC,GAAkB3E,EAAKwC,WAAW8B,EAAMK,IACrCD,GAER,MAtJH,CAAA9C,IAAA,iBAAAC,MAAA,SA+JgBe,GAA8B,IAAAgC,EAAA3E,KACtCqE,EAAQrE,KAAKsE,sBAAsB3B,GACzC,OAAOtC,OAAOkE,KAAKF,GAAOG,OACzB,SAACC,EAAkBC,GAElB,OADAD,EAAIC,GAAkBC,EAAKC,cAAcP,EAAMK,IACxCD,GAER,MAtKH,CAAA9C,IAAA,oBAAAC,MAAA,SAmLEiD,EACAC,EACAC,EACAC,GAEA,OAAOF,GAAQC,GAAQC,GAAQH,IAxLjC,CAAAlD,IAAA,kBAAAC,MAAA,SAiMiBqD,EAAmBC,GAClC,OAAgD,OAAzClF,KAAKmF,cAAcF,EAASC,KAlMrC,CAAAvD,IAAA,oBAAAC,MAAA,SA2MmBqD,EAAmBC,GACpC,OAAkD,OAA3ClF,KAAKoF,gBAAgBH,EAASC,KA5MvC,CAAAvD,IAAA,kBAAAC,MAAA,SAqNiBqD,EAAmBC,GAClC,IAAIG,EAAIrF,KAAKsF,UAAUL,GACnBM,EAAIvF,KAAKsF,UAAUJ,GAEvB,OAAIlF,KAAKwF,kBAAkBH,EAAEvC,KAAMuC,EAAEtC,KAAMwC,EAAEzC,KAAMyC,EAAExC,MAC7C,IACG/C,KAAKwF,kBAAkBH,EAAErC,KAAMqC,EAAEpC,KAAMsC,EAAEvC,KAAMuC,EAAEtC,MACpD,IACGjD,KAAKwF,kBAAkBH,EAAEnC,KAAMmC,EAAElC,KAAMoC,EAAErC,KAAMqC,EAAEpC,MACpD,IAEA,OAhOV,CAAAxB,IAAA,gBAAAC,MAAA,SA2OEqD,EACAC,GAEA,IAAIG,EAAIrF,KAAKyF,aAAaR,GACtBM,EAAIvF,KAAKyF,aAAaP,GAE1B,OAAIlF,KAAKwF,kBAAkBH,EAAEvC,KAAMuC,EAAEtC,KAAMwC,EAAEzC,KAAMyC,EAAExC,MAC7C,IACG/C,KAAKwF,kBAAkBH,EAAErC,KAAMqC,EAAEpC,KAAMsC,EAAEvC,KAAMuC,EAAEtC,MACpD,IACGjD,KAAKwF,kBAAkBH,EAAE3B,KAAM2B,EAAE1B,KAAM4B,EAAE7B,KAAM6B,EAAE5B,MACpD,IAEA,OAxPV,CAAAhC,IAAA,gBAAAC,MAAA,SAkQeqD,EAAmBC,GAEhC,IAAKlF,KAAKoF,gBAAgBH,EAASC,GAAU,OAAO,KAFgB,IAAAQ,EAKrD,CAAC1F,KAAKsF,UAAUL,GAAUjF,KAAKsF,UAAUJ,IAAjDG,EAL6DK,EAAA,GAK1DH,EAL0DG,EAAA,GAOpE,OAAQ1F,KAAKoF,gBAAgBH,EAASC,IACrC,IAAK,IACJ,OAAOG,EAAEvC,KAAOyC,EAAEzC,KAAOmC,EAAUC,EACpC,IAAK,IACJ,OAAOG,EAAErC,KAAOuC,EAAEvC,KAAOiC,EAAUC,EACpC,IAAK,IACJ,OAAOG,EAAEnC,KAAOqC,EAAErC,KAAOgC,EAAUD,EACpC,QACC,KAAM,wCAjRV1D,EAAA,0BClDO,SAASoE,EAAMC,GACrB,OAAOvF,OAAAwF,EAAA,EAAAxF,CAAIyF,MAAMF,IAAMG,IAAI,SAACC,EAAGC,GAAJ,OAAUA,IAG/B,SAASC,EAAKC,EAAcC,GAClCD,EAAME,OAAOF,EAAMG,QAAQF,GAAU,GAG/B,SAASG,EAAQ1E,GACvB,SAAA2E,OAAU3E,EAAMC,EAAhB,KAAA0E,OAAqB3E,EAAME,EAA3B,KAGM,SAAS0E,EAAWC,GAA+B,IAAdC,IAAczG,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GACzD,WAAAsG,OAAYD,EAAQG,EAAO,IAA3B,OAAAF,OAAoCE,EAAOE,MAAM,GAAGb,IAAI,SAACc,GAAD,OAAON,EAAQM,KAAvE,KAAAL,OACCG,EAAQ,IAAM,QCOZG,UCFEC,EAAW,CAChBvF,OAAQ,SAACwF,EAAeC,GAAhB,MAAoC,CAC3CnF,EAAGkF,EAAQ,EACXjF,EAAGkF,EAAS,IAEbxF,MAAO,GACPqF,OAAQ,IAGII,EAAb,WASC,SAAAA,IAAiD,IAAAnH,EAAAC,KAArCmH,EAAqCjH,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAjB,GAAiBG,OAAAC,EAAA,EAAAD,CAAAL,KAAAkH,GAAAlH,KARjD8G,YAQiD,EAAA9G,KAPjDoH,OAAkB,GAO+BpH,KANjDqH,YAMiD,EAAArH,KALjDsH,aAKiD,EAAAtH,KAJjDuH,aAIiD,EAAAvH,KAHjDwH,cAGiD,EAAAxH,KAFjDyH,YAEiD,EAAAzH,KA+BjD0H,WAAa,SAAC/E,GACb5C,EAAKwH,QAAU5E,GAhCiC3C,KA0CjD2H,aAAe,SACdhF,EACAiF,EACAhG,GAEI,IADJiG,EACI3H,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GADO,IAEPyC,EAAMnC,OACVmC,EAAMnC,MAAO,EAEbsH,YAAMzH,OAAA0H,EAAA,EAAA1H,CAAA,CACL2H,QAASrF,EAAMiF,GACfK,OAAQ,cACRJ,WACAK,OAAQ,WACPnI,EAAKoI,YAAYxF,GACjB5C,EAAKqI,QAENC,SAAU,WACT1F,EAAMnC,MAAO,IAGXoB,MA/D4C5B,KAmEjDsI,UAAY,SACX3F,EACA4F,GACI,IAEAC,EAFA5F,EACgBD,EAAM9C,SAAlBiC,EADJc,EACId,EAAGC,EADPa,EACOb,EAAGC,EADVY,EACUZ,EAGd,OAAQuG,GACP,IAAK,QACJC,EAAO,CAAE1G,EAAGA,EAAI,EAAGC,IAAGC,KACtB,MACD,IAAK,OACJwG,EAAO,CAAE1G,IAAGC,EAAGA,EAAI,EAAGC,KACtB,MACD,IAAK,QACJwG,EAAO,CAAE1G,EAAGA,EAAI,EAAGC,IAAGC,KACtB,MACD,IAAK,OACJwG,EAAO,CAAE1G,IAAGC,EAAGA,EAAI,EAAGC,KACtB,MACD,QACCwG,EAAO,CAAE1G,IAAGC,IAAGC,KAGjB,IAAMyG,EAAa1I,EAAK2I,UAAUF,GAC5BrF,EAAOwF,gBAAMF,EAAY,SAAClD,GAAD,OAAOA,EAAE1F,SAASmC,IAC5CmB,IACLqF,EAAKxG,EAAImB,EAAKtD,SAASmC,EAAImB,EAAKrD,KAAKkC,EAErCjC,EAAK4H,aAAahF,EAAO,WAAY6F,KAhGWxI,KAuGjDmI,YAA6C,SAACxF,GAQ7C,OAPAtC,OAAOuI,OAAOjG,EAAO,CACpBhC,KAAMZ,EAAKuH,QAAQuB,QAAQlG,GAC3BpC,MAAOR,EAAKuH,QAAQwB,SAASnG,GAC7BlC,WAAYV,EAAKuH,QAAQyB,cAAcpG,GACvCjC,QAASX,EAAKuH,QAAQ0B,WAAWrG,KAG3BA,GA/GyC3C,KAqHjDiJ,OAA2B,WAE1B,OADelJ,EAAKmJ,WAAWnJ,EAAK+G,QACtBf,IAAIhG,EAAKoI,cAvHyBnI,KA+PjDmJ,cAAgB,SAACtH,GAAkB,IAC5BC,EAAYD,EAAZC,EAAGC,EAASF,EAATE,EAAGC,EAAMH,EAANG,EAKZ,OAJAF,EAAII,KAAKM,MAAMV,GACfC,EAAIG,KAAKM,MAAMT,GACfC,EAAIE,KAAKM,MAAMR,GAERjC,EAAK+G,OAAOsC,KAAK,SAACzG,GAAU,IAAAiB,EACFjB,EAAM9C,SAA3BwJ,EADuBzF,EAC1B9B,EAAUwH,EADgB1F,EACnB7B,EAAUwH,EADS3F,EACZ5B,EAEtB,OAAOF,IAAMuH,GAAMtH,IAAMuH,GAAMtH,IAAMuH,KAxQUvJ,KA4QjD0I,UAAY,SAAC7G,GAAkB,IACxBC,EAAYD,EAAZC,EAAGC,EAASF,EAATE,EAAGC,EAAMH,EAANG,EAKZ,OAJAF,EAAII,KAAKM,MAAMV,GACfC,EAAIG,KAAKM,MAAMT,GACfC,EAAIE,KAAKM,MAAMR,GAERwH,iBACNzJ,EAAK+G,OAAO2C,OAAO,SAAC9G,GAAU,IAAA+G,EACJ/G,EAAM9C,SAApBwJ,EADkBK,EACrB5H,EAAUwH,EADWI,EACd3H,EAEf,OAAOD,IAAMuH,GAAMtH,IAAMuH,IAE1B,eAxR+CtJ,KAgSjD2J,UAAY,SAAC9H,GAAuD,IAAjC+H,EAAiC1J,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAzB,CAAE4B,EAAG,EAAGC,EAAG,EAAGC,EAAG,GACtDH,GAKL9B,EAAK0H,OAAS,IAAI7H,EAAMiC,EAAO+H,GAC/B7J,EAAKoI,YAAYpI,EAAK0H,SALrB1H,EAAK0H,YAASrH,GAlSiC,IAE/C6G,EAKGE,EALHF,OACAD,EAIGG,EAJHH,MAH+C6C,EAO5C1C,EAHH3F,cAJ+C,IAAAqI,EAItC9C,EAASvF,OAJ6BqI,EAAAC,EAO5C3C,EAFH1F,aAL+C,IAAAqI,EAKvC/C,EAAStF,MAL8BqI,EAAAC,EAO5C5C,EADHL,cAN+C,IAAAiD,EAMtChD,EAASD,OAN6BiD,EAQhD/J,KAAKqH,OAAS,IAAI9F,EAAOC,EAAOyF,EAAQD,GAAQvF,GAChDzB,KAAKsH,QAAU,IAAI0C,EAAQhK,KAAKqH,QAChCrH,KAAK8G,OAASA,EACd9G,KAAKoI,OACLpI,KAAKiJ,SArBP,OAAA5I,OAAAqB,EAAA,EAAArB,CAAA6G,EAAA,EAAAvF,IAAA,OAAAC,MAAA,WAyBE5B,KAAKoH,OAASpH,KAAKiK,cAzBrB,CAAAtI,IAAA,YAAAC,MAAA,WAiCE,OAAO5B,KAAKkJ,WAAWlJ,KAAK8G,UAjC9B,CAAAnF,IAAA,YAAAC,MAAA,SAwIWkF,GAMT,OALAhB,MAAMoE,QAAQpD,GACV9G,KAAK8G,OAAS9G,KAAK8G,OAAON,OAAOM,GACjC9G,KAAK8G,OAAL,GAAAN,OAAAnG,OAAAwF,EAAA,EAAAxF,CAAkBL,KAAK8G,QAAvB,CAA+BA,IAEnC9G,KAAKiJ,SACEjJ,KAAK8G,SA9Id,CAAAnF,IAAA,cAAAC,MAAA,SAsJakF,GACX,GAAIhB,MAAMoE,QAAQpD,GAAS,KAAAqD,GAAA,EAAAC,GAAA,EAAAC,OAAAjK,EAAA,IAC1B,QAAAkK,EAAAC,EAAkBzD,EAAlB0D,OAAAC,cAAAN,GAAAG,EAAAC,EAAA/B,QAAAkC,MAAAP,GAAA,EAA0B,KAAjBxH,EAAiB2H,EAAA1I,MACzBsE,EAAKlG,KAAK8G,OAAQnE,IAFO,MAAAgI,GAAAP,GAAA,EAAAC,EAAAM,EAAA,YAAAR,GAAA,MAAAI,EAAAK,QAAAL,EAAAK,SAAA,WAAAR,EAAA,MAAAC,SAK1BnE,EAAKlG,KAAK8G,OAAQA,GAGnB,OAAO9G,KAAK8G,SA/Jd,CAAAnF,IAAA,aAAAC,MAAA,SAsKYkF,GAA0B,IAChCb,EACH4E,EAUGxF,EAAUE,EAAUuF,EAZYnG,EAAA3E,KAGnC+K,EAAYjE,EAAO3G,OAGpB,IAAK8F,EAAI,EAAGA,EAAI8E,EAAW9E,IAC1Ba,EAAOb,GAAG9E,aAAe,GACzB2F,EAAOb,GAAG7E,cAAgB,GAK3B,IAAK6E,EAAI,EAAGA,EAAI8E,EAAW9E,IAG1B,IAFAZ,EAAIyB,EAAOb,GAEN4E,EAAI5E,EAAI,EAAG4E,EAAIE,EAAWF,IAC9BtF,EAAIuB,EAAO+D,IACXC,EAAa9K,KAAKqH,OAAO2D,cAAc3F,EAAGE,MAErCF,IAAMyF,GACTzF,EAAElE,aAAa8J,KAAK1F,GACpBA,EAAEnE,cAAc6J,KAAK5F,KAErBE,EAAEpE,aAAa8J,KAAK5F,GACpBA,EAAEjE,cAAc6J,KAAK1F,KAQzB,IAAI2F,EAAwB,GAC5B,IAAKjF,EAAI,EAAGA,EAAI8E,EAAW9E,IACY,IAAlCa,EAAOb,GAAG9E,aAAahB,QAC1B+K,EAAaD,KAAKnE,EAAOb,IAM3B,IADA,IAAIkF,EAAuB,GACpBD,EAAa/K,OAAS,GAAG,CAG/B,IAAIwC,EAAQuI,EAAaE,MACzB,IAAKzI,EAAO,OAAOwI,EAKnB,IAJAA,EAAYF,KAAKtI,GAIZkI,EAAI,EAAGA,EAAIlI,EAAMvB,cAAcjB,OAAQ0K,IAAK,CAChD,IAAIQ,EAAQ1I,EAAMvB,cAAcyJ,GAIhC3E,EAAKmF,EAAMlK,aAAcwB,GACS,IAA9B0I,EAAMlK,aAAahB,QACtB+K,EAAaD,KAAKI,IAUrB,OAJAF,EAAYG,QAAQ,SAAC3I,GACpBA,EAAM/B,SAAW+D,EAAK4G,kBAAkB5I,KAGlCwI,IA1OT,CAAAxJ,IAAA,oBAAAC,MAAA,SAmTmBe,GAAiB,IAAA6I,EACd7I,EAAM9C,SAAlBiC,EAD0B0J,EAC1B1J,EAAGC,EADuByJ,EACvBzJ,EAAGC,EADoBwJ,EACpBxJ,EAEd,MAAO,CACNnB,MAAOb,KAAKmJ,cAAc,CAAErH,EAAGA,EAAI,EAAGC,IAAGC,MACzChB,KAAMhB,KAAKmJ,cAAc,CAAErH,IAAGC,EAAGA,EAAI,EAAGC,MACxCf,MAAOjB,KAAKmJ,cAAc,CAAErH,IAAGC,IAAGC,EAAGA,EAAI,IACzCjB,MAAOf,KAAKmJ,cAAc,CAAErH,EAAGA,EAAI,EAAGC,IAAGC,MACzClB,KAAMd,KAAKmJ,cAAc,CAAErH,IAAGC,EAAGA,EAAI,EAAGC,MACxCd,MAAOlB,KAAKmJ,cAAc,CAAErH,IAAGC,IAAGC,EAAGA,EAAI,SA5T5CkF,EAAA,GC7Ba8C,EAAb,WAGC,SAAAA,EAAY3C,GAAiBhH,OAAAC,EAAA,EAAAD,CAAAL,KAAAgK,GAAAhK,KAF7BqH,YAE4B,EAC3BrH,KAAKqH,OAASA,EAJhB,OAAAhH,OAAAqB,EAAA,EAAArB,CAAA2J,EAAA,EAAArI,IAAA,UAAAC,MAAA,SAOSe,GACP,IAAMP,EAAIpC,KAAKqH,OAAOoE,eAAe9I,GADL+I,EAEmB/I,EAAM/B,SAAjDC,EAFwB6K,EAExB7K,MAAOC,EAFiB4K,EAEjB5K,KAAMC,EAFW2K,EAEX3K,MAAOC,EAFI0K,EAEJ1K,KAAMC,EAFFyK,EAEEzK,MAAOC,EAFTwK,EAESxK,MAErCyK,EAAI,GACJC,EAAI,GAUR,OARK/K,GAAUI,IAAO2K,GAAKnF,EAAW,CAACrE,EAAEmB,OAAQnB,EAAE8B,UAAU,IACxDrD,GAAUC,IAAM8K,GAAKnF,EAAW,CAACrE,EAAE8B,QAAS9B,EAAEqB,YAAY,IAC1D3C,GAASI,IAAO0K,GAAKnF,EAAW,CAACrE,EAAEqB,UAAWrB,EAAEkB,YAAY,IAE5DtC,GAASC,IAAO0K,GAAKlF,EAAW,CAACrE,EAAEmB,OAAQnB,EAAE+B,SAAS,IACtDnD,GAASD,IAAO4K,GAAKlF,EAAW,CAACrE,EAAE+B,OAAQ/B,EAAEoB,WAAW,IACxDzC,GAAUG,IAAOyK,GAAKlF,EAAW,CAACrE,EAAEoB,SAAUpB,EAAEkB,YAAY,IAE1DqI,EAAIC,IAtBb,CAAAjK,IAAA,gBAAAC,MAAA,SAyBee,GACb,IAAMP,EAAIpC,KAAKqH,OAAOoE,eAAe9I,GACrC,OAAO8D,EAAW,CACjBrE,EAAEkB,UACFlB,EAAEoB,SACFpB,EAAE+B,OACF/B,EAAEmB,OACFnB,EAAE8B,QACF9B,EAAEqB,cAjCL,CAAA9B,IAAA,WAAAC,MAAA,SAqCUe,GACR,IAAMP,EAAIpC,KAAKqH,OAAOoE,eAAe9I,GAErC,MAAO,CACN,CAACP,EAAEgC,QAAShC,EAAE+B,OAAQ/B,EAAEmB,OAAQnB,EAAE8B,SAClC,CAAC9B,EAAEkB,UAAWlB,EAAEoB,SAAUpB,EAAE+B,OAAQ/B,EAAEgC,SACtC,CAAChC,EAAEkB,UAAWlB,EAAEqB,UAAWrB,EAAE8B,QAAS9B,EAAEgC,UACvC2B,IAAI,SAAC8F,GAAD,OAAUpF,EAAWoF,OA5C7B,CAAAlK,IAAA,aAAAC,MAAA,SA+CYe,GACV,IAAMP,EAAIpC,KAAKqH,OAAOoE,eAAe9I,GAErC,OACC8D,EAAW,CACVrE,EAAEkB,UACFlB,EAAEoB,SACFpB,EAAE+B,OACF/B,EAAEmB,OACFnB,EAAE8B,QACF9B,EAAEqB,YAEHgD,EAAW,CAACrE,EAAEgC,QAAShC,EAAEkB,YACzBmD,EAAW,CAACrE,EAAEgC,QAAShC,EAAE+B,SACzBsC,EAAW,CAACrE,EAAEgC,QAAShC,EAAE8B,cA7D5B8F,EAAA,GC0Fe9C,ICjFT4E,EAAS,CACdC,KAAM,CAAC,OAAQ,OAAQ,OAAQ,OAAQ,QACvCC,OAAQ,CAAC,OAAQ,OAAQ,OAAQ,OAAQ,SAGpCC,mLACI,IAAAC,EACwClM,KAAKmM,MAA7CxJ,EADAuJ,EACAvJ,MAAcyJ,GADdF,EACOrK,MADPqK,EACcE,cAAcC,EAD5BH,EAC4BG,QAE5B1M,EAAmCgD,EAAnChD,MAAOY,EAA4BoC,EAA5BpC,MAAOI,EAAqBgC,EAArBhC,KAEhBgB,GAFqCgB,EAAflC,WAEnB,GAAA+F,OAAM7D,EAAM9C,SAASiC,EAArB,KAAA0E,OAA0B7D,EAAM9C,SAASkC,EAAzC,KAAAyE,OAA8C7D,EAAM9C,SAASmC,IAEhEsK,EAAgBR,EAAOnM,GAE7B,OACC4M,EAAAlH,EAAAmH,cAAA,KACCJ,aACCA,EACG,SAACK,GACDL,EAAazJ,SAEbvC,EAEJiM,QAASA,EAAU,kBAAMA,EAAQ1J,SAASvC,GAEzCG,EAAMwF,IAAI,SAAC8F,EAAMa,GACjB,IAAIC,EAAOL,EAAcI,GAEzB,OACCH,EAAAlH,EAAAmH,cAAA,QACC7K,IAAG,SAAA6E,OAAW7E,EAAX,UAAA6E,OAAuBkG,GAC1BE,EAAGf,EACHgB,OAAO,OACPF,KAAMA,EACNG,YAAY,QAIdnM,GACA4L,EAAAlH,EAAAmH,cAAA,QACCI,EAAGjM,EACHkM,OAAQP,EAAc,GACtBK,KAAK,OACLG,YAAa,aAvCIC,aAuDRC,cAASf,GCjElBgB,mLACI,IACAxF,EAAWzH,KAAKmM,MAAMe,IAAtBzF,OAER,IAAKA,EAAQ,OAAO8E,EAAAlH,EAAAmH,cAAA,UAHZ,IAKA/L,EAAegH,EAAfhH,WAER,OACC8L,EAAAlH,EAAAmH,cAAA,KAAGW,cAAe,QACjBZ,EAAAlH,EAAAmH,cAAA,QAAMI,EAAGnM,EAAYoM,OAAO,OAAOF,KAAK,oCAVbI,aAgBhBC,cAASC,GCflBG,mLACI,IAAAlB,EACiBlM,KAAKmM,MAAtBe,EADAhB,EACAgB,IAAKG,EADLnB,EACKmB,QADLC,EAEkBJ,EAAI7F,OAAtB5F,EAFA6L,EAEA7L,MAAOD,EAFP8L,EAEO9L,OACPM,EAASN,EAATM,EAAGC,EAAMP,EAANO,EAEX,OACCwK,EAAAlH,EAAAmH,cAAA,KACCe,UAAS,aAAA/G,OAAe1E,EAAf,MAAA0E,OAAqBzE,EAAIsL,EAAU5L,EAAnC,KACT0L,cAAe,QAEfZ,EAAAlH,EAAAmH,cAAA,QACCI,EAAC,mBACDC,OAAO,OACPF,KAAK,4BAENJ,EAAAlH,EAAAmH,cAAA,QACC1K,EAAG,EACHC,EAAG,GACHyL,WAAY,SACZC,SAAU,GACVC,WAAW,OACXf,KAAK,2BAEJU,WAxByBN,aA+BhBC,cAASI,UNnCxBO,YAASzG,EAAU,CAElBE,OAAQwG,IACRC,UAAWC,IACXvG,QAASqG,IACTnG,OAAQmG,IACRlG,WAAYoG,IACZxF,UAAWwF,IACXtG,SAAUoG,IACVxF,KAAM0F,MAGPH,YAAS/N,EAAO,CACfC,SAAU+N,IACV9N,KAAM8N,IACNnN,WAAYmN,IACZrN,MAAOqN,IACPvM,OAAQyM,IAAOC,MACfzM,SAAUwM,IAAOC,QAKlBjH,EAAS,IAETA,EAASnB,EAAM,IACbI,IAAI,SAAChE,GAAD,OACJ4D,EAAM,IAAII,IACT,SAACjE,GAAD,OACC,IAAIlC,EACH,CAAEkC,IAAGC,IAAGC,EAAG,GACX,CAAEF,EAAG,EAAGC,EAAG,EAAGC,EAAG,QAIpBgM,QAEK/C,KAAK,IAAIrL,EAAM,CAAEkC,EAAG,EAAGC,EAAG,EAAGC,EAAG,GAAK,CAAEF,EAAG,EAAGC,EAAG,EAAGC,EAAG,KAE7D,IAAMiM,EAAS,IAAIrO,EAClB,CAAEkC,EAAG,IAAMC,EAAG,IAAMC,EAAG,GACvB,CAAEF,EAAG,GAAKC,EAAG,GAAKC,EAAG,KACrB,CAAErC,MAAO,WAGVmH,EAAOmE,KAAKgD,GAEZ,IAAMf,EAAM,IAAIhG,EAAS,CACxBD,OAAQ,IACRD,MAAO,IACPvF,MAAO,GACPD,OAAQ,SAACS,EAAGiM,GAAJ,MAAW,CAAEpM,EAAGoM,EAAI,EAAGnM,EAAO,IAAJE,IAClC6E,OAAQA,IAGToG,EAAI1F,SAAWyG,EAEAf,QOxCTiB,6MACLC,UAA6CC,IAAMC,cACnDC,WAAoB,CAAEzM,EAAG,EAAGC,EAAG,KAM/ByM,MAAQ,CACPC,YAAY,EACZpB,QAAS,EACTvG,OAAQ,MAuDT4H,YAAc,SAACC,GACd,IAAMtM,EAAWtC,EAAK6O,WAAW7O,EAAKwO,YACjClM,GAELtC,EAAK8O,YAAYxM,MAGlByM,gBAAkB,SAACH,GAClB5O,EAAKwO,WAAa,CAAEzM,EAAG6M,EAAMI,MAAOhN,EAAG4M,EAAMK,OAC7CjP,EAAK4J,UAAU5J,EAAKwO,WAA8B,IAAlBI,EAAMM,YAGvCtF,UAAY,SAAC9H,EAAcqN,GAAmB,IAAAC,EACbpP,EAAKyO,MAA7BC,EADqCU,EACrCV,WAAYpB,EADyB8B,EACzB9B,QACpB,GAAKoB,EAAL,CAEA,IAAMpM,EAAWtC,EAAK6O,WAAW/M,GAC5BQ,IAED6M,GAAOnP,EAAK8O,YAAYxM,GAE5B6K,EAAIvD,UAAU,CAAE7H,EAAGO,EAASP,EAAGC,EAAGM,EAASN,EAAGC,EAAGqL,iFAzEvCxL,GAA4B,IAAdW,IAActC,UAAAC,OAAA,QAAAC,IAAAF,UAAA,KAAAA,UAAA,GAChCkO,EAAYpO,KAAKoO,UAAUgB,QACzBlC,EAAQlN,KAAKmM,MAAbe,IAER,GAAKkB,EAAL,CAEA,IAAMiB,EAAS,CACdvN,EAAGD,EAAMC,EAAIsM,EAAUkB,WACvBvN,EAAGF,EAAME,EAAIqM,EAAUmB,UACvBvN,EAAGhC,KAAKwO,MAAMnB,SAGf,OAAOH,EAAI7F,OAAOmI,YAAYH,EAAQ7M,iDAGlB,IAAAmC,EAAA3E,KAiBpByP,OAAOC,iBAAiB,WAAY,SAACf,GAAU,IACtCtB,EAAY1I,EAAK6J,MAAjBnB,QACFsC,EAAsC,CAC3CC,EAAG,kBAAMjL,EAAKkL,SAAS,CAAExC,QAASA,EAAU,KAC5CyC,EAAG,kBAAMnL,EAAKkL,SAAS,CAAExC,QAASA,EAAU,KAC5Ca,EAAG,kBAAMhB,EAAI1F,UAAY0F,EAAI5E,UAAU4E,EAAI1F,SAAU,UACrDuI,EAAG,kBAAM7C,EAAI1F,UAAY0F,EAAI5E,UAAU4E,EAAI1F,SAAU,UACrDnC,EAAG,kBAAM6H,EAAI1F,UAAY0F,EAAI5E,UAAU4E,EAAI1F,SAAU,SACrDoF,EAAG,kBAAMM,EAAI1F,UAAY0F,EAAI5E,UAAU4E,EAAI1F,SAAU,UAGtD,IACCmI,EAAYhB,EAAMhN,OAClBgD,EAAKgF,UAAUhF,EAAK4J,YAAY,GAC/B,MAAOuB,wFA8BCjO,GAAiB,IACpBC,EAASD,EAATC,EAAGC,EAAMF,EAANE,EACMC,EAAMhC,KAAKwO,MAApBnB,QAERH,EAAIW,UAAU,IAAIjO,EAAM,CAAEkC,IAAGC,IAAGC,KAAK,CAAEF,EAAG,EAAGC,EAAG,EAAGC,EAAG,sCAG9C,IAAAgO,EAAAhQ,KACAkN,EAAQlN,KAAKmM,MAAbe,IACA9F,EAAW8F,EAAX9F,OAFA6I,EAGwBjQ,KAAKwO,MAA7BnB,EAHA4C,EAGA5C,QAASoB,EAHTwB,EAGSxB,WAEbyB,EAAe,CAAEC,MAAO,GAAIC,MAAO,GAAIC,OAAQ,IAqBnD,OAfI5B,EACHrH,EAAO5C,OAAO,SAACC,EAAKC,GAQnB,OAPIA,EAAI7E,SAASmC,EAAIqL,EACpB5I,EAAI2L,MAAMnF,KAAKvG,GACLA,EAAI7E,SAASmC,EAAIqL,EAC3B5I,EAAI4L,OAAOpF,KAAKvG,GAEhBD,EAAI0L,MAAMlF,KAAKvG,GAETD,GACLyL,GAEHA,EAAaC,MAAQ/I,EAIrBmF,EAAAlH,EAAAmH,cAAA,OAAK8D,UAAU,OACd/D,EAAAlH,EAAAmH,cAAA,OACC+D,IAAKvQ,KAAKoO,UACVoC,MAAO,CACNC,OAAQ,SACRxJ,OAAQ,IACRD,MAAO,IACPnH,SAAU,WACV4H,OAAQ,QAET2E,aAAc,kBAAM4D,EAAKH,SAAS,CAAEpB,YAAY,KAChDiC,aAAc,kBACbV,EAAKH,SAAS,CAAEpB,YAAY,GAAS,kBAAMvB,EAAIvD,UAAU,UAG1D4C,EAAAlH,EAAAmH,cAAA,OACCmE,QAAQ,cACRH,MAAO,CACN3Q,SAAU,WACV+Q,KAAM,EACNC,IAAK,EACLC,OAAQ,iBACR7J,OAAQ,IACRD,MAAO,KAER+J,YAAa/Q,KAAK8O,gBAClBzC,QAASrM,KAAK0O,aAEdnC,EAAAlH,EAAAmH,cAAA,KAAG7K,IAAG,uBAA0BqP,QAAS,KACvCd,EAAaE,MAAMrK,IAAI,SAACpD,EAAOsO,GAC/B,OACC1E,EAAAlH,EAAAmH,cAAC0E,EAAD,CACCvP,IAAG,SAAA6E,OAAWyK,GACdtO,MAAOA,EACPd,MAAOqL,EAAI7F,OAAOzC,cAAcjC,EAAM9C,eAK1C0M,EAAAlH,EAAAmH,cAAA,KAAG7K,IAAG,yBAA4BqP,QAAS,GACzCd,EAAaC,MAAMpK,IAAI,SAACpD,EAAOsO,GAC/B,OACC1E,EAAAlH,EAAAmH,cAAC0E,EAAD,CACCvP,IAAG,SAAA6E,OAAWyK,GACdtO,MAAOA,EACPd,MAAOqL,EAAI7F,OAAOzC,cAAcjC,EAAM9C,eAK1C0M,EAAAlH,EAAAmH,cAAA,KAAG7K,IAAG,wBAA2BqP,QAAS,KACxCd,EAAaG,OAAOtK,IAAI,SAACpD,EAAOsO,GAChC,OACC1E,EAAAlH,EAAAmH,cAAC0E,EAAD,CACCvP,IAAG,SAAA6E,OAAWyK,GACdtO,MAAOA,EACPd,MAAOqL,EAAI7F,OAAOzC,cAAcjC,EAAM9C,eAzC3C,MA+CE4O,GACAlC,EAAAlH,EAAAmH,cAAAD,EAAAlH,EAAA8L,SAAA,KACC5E,EAAAlH,EAAAmH,cAAC4E,EAAD,CAAkBlE,IAAKA,IACvBX,EAAAlH,EAAAmH,cAAC6E,EAAD,CAAkBnE,IAAKA,EAAKG,QAASA,eA7L3BN,aAAZoB,EAIEmD,aAAe,CACrBpE,OAmMaF,kBAASmB,GClNJoD,QACW,cAA7B9B,OAAO+B,SAASC,UAEe,UAA7BhC,OAAO+B,SAASC,UAEhBhC,OAAO+B,SAASC,SAASC,MACvB,2DCZNC,IAAS1I,OAAOsD,EAAAlH,EAAAmH,cAACoF,EAAD,MAASC,SAASC,eAAe,SDmI3C,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAMC,KAAK,SAAAC,GACjCA,EAAaC","file":"static/js/main.f3365103.chunk.js","sourcesContent":["import { Point3, AdjacentBlocks } from './index'\nimport { decorate, action, observable } from 'mobx'\n\nconst blockOptions = {\n\tcolor: 'grey',\n}\n\n// Block\n\nexport class Block {\n\tcolor: string\n\tfaces = [] as string[]\n\tbusy = false\n\tsilhouette = ''\n\toutline = ''\n\tedge = ''\n\tadjacent: AdjacentBlocks = {\n\t\tnorth: undefined,\n\t\teast: undefined,\n\t\tsouth: undefined,\n\t\twest: undefined,\n\t\tabove: undefined,\n\t\tbelow: undefined,\n\t}\n\n\tposition: Point3\n\tsize: Point3\n\tblocksBehind: Block[] = []\n\tblocksInFront: Block[] = []\n\n\tconstructor(position: Point3, size: Point3, options = blockOptions) {\n\t\tthis.position = position\n\t\tthis.size = size\n\t\tthis.color = options.color\n\t}\n\n\tmoveTo = (position: Point3) => {\n\t\tthis.position = position\n\t}\n\n\tresizeTo = (size: Point3) => {\n\t\tthis.size = size\n\t}\n}\n","import {\n\tIsoBlock,\n\tPoint,\n\tVertice,\n\tVerts,\n\tPoint3,\n\tBounds,\n\tScreenVerts,\n\tIsoPoint,\n\tIsoBounds,\n\tIsoVerts,\n\tSeparationAxis,\n\tIsoSeparationAxis,\n} from './index'\n\n/**\n* @description A camera for handling interactions of 3D space (x, y, z), isometric 2D space, and the 2D space of the screen.\n* @remarks We have three separate coordinate systems used for different things:\n\n1. Space (3D)\n\nWe apply the usual 3D coordinates to define the boxes using x,y,z.\n\n2. Isometric (2D)\n\nWhen the 3D space is flattened into an isometric view, we use oblique x and y\naxes separated by 120 degrees.\n\nAll this does is treat all 3d coordinates as if they are at z=0.\n\nFor example, if use have a box at (0,0,0) and we raised it to (0,0,1), it would\nlook to be in the exact same position as a box at (1,1,0), so the 2d isometric\ncoordinates are (1,1).  This is a side effect of the isometric perspective.  So\nthe isometric 2D coordinates gets the \"apparent\" coordinates for all boxes if\nthey were at z=0.\n\nThis is accomplished by adding z to x and y.  That is all.\n\n(Isometric coordinates are useful for determining when boxes overlap on the\nscreen.)\n\n3. Screen (2D)\n\nBefore drawing, we convert the isometric coordinates to the usual x,y screen\ncoordinates.\n\nThis is done by multiplying each isometric 2D coordinate by its respective\noblique axis vector and taking the sum.\n\nWe then multiply this position by \"scale\" value to implement zoom in/out\nfeatures for the camera.\n\nThen we add to an \"origin\" to implement panning features for the camera.\n* @class Camera\n*/\nexport class Camera {\n\torigin: Point\n\tscale: number\n\n\t/**\n\t * Creates an instance of Camera.\n\t * @param origin - the pixel location of the isometric origin\n\t * @param scale - number of pixels per isometric unit\n\t */\n\tconstructor(origin: Point, scale: number) {\n\t\tthis.origin = origin\n\t\tthis.scale = scale\n\t}\n\n\t/**\n\t * Convert the given 3D space coordinates to 2D isometric coordinates.\n\t * @param point - The 3D point\n\t * @returns - The isometric point\n\t */\n\tspaceToIso(point: Point3) {\n\t\tlet { x, y, z } = point\n\n\t\tx += z\n\t\ty += z\n\n\t\treturn {\n\t\t\tx: x,\n\t\t\ty: y,\n\t\t\th: ((x - y) * Math.sqrt(3)) / 2, // Math.cos(Math.PI/6)\n\t\t\tv: (x + y) / 2, // Math.sin(Math.PI/6)\n\t\t} as IsoPoint\n\t}\n\n\t/**\n\t * Convert the given 2D isometric coordinates to 2D screen coordinates.\n\t * @param point - The isometric point\n\t * @returns - The 2D point\n\t */\n\tisoToScreen(isoPoint: IsoPoint) {\n\t\tconst { h, v } = isoPoint\n\t\treturn {\n\t\t\tx: h * this.scale + this.origin.x,\n\t\t\ty: -v * this.scale + this.origin.y,\n\t\t}\n\t}\n\n\t/**\n\t * Convert the given 3D space coordinates to 2D screen coordinates.\n\t * @param  point\n\t * @returns - The 2D point\n\t */\n\tspaceToScreen(point: Point3): Point {\n\t\treturn this.isoToScreen(this.spaceToIso(point))\n\t}\n\n\t/**\n\t * Convert the given 2D screen coordinate to 2D isometric coordinate\n\t * @param point - The 2D point\n\t */\n\tscreenToIso(point: Point3, floor = false): IsoPoint {\n\t\tpoint.x -= this.origin.x + point.z\n\t\tpoint.y -= this.origin.y + point.z\n\n\t\tconst tHeight = this.scale\n\t\tconst tWidth = this.scale * 1.732\n\n\t\tlet y = (-point.x / (tWidth / 2) - point.y / (tHeight / 2)) / 2\n\t\tlet x = (-point.y / (tHeight / 2) + point.x / (tWidth / 2)) / 2\n\n\t\tif (floor) {\n\t\t\tx = Math.floor(x)\n\t\t\ty = Math.floor(y)\n\t\t}\n\n\t\treturn {\n\t\t\tx,\n\t\t\ty,\n\t\t\th: -((x - y) * Math.sqrt(3)) / 2, // Math.cos(Math.PI/6)\n\t\t\tv: (x + y) / 2, // Math.sin(Math.PI/6)\n\t\t}\n\t}\n\n\t/**\n\t * For the given block, get the min and max values on each 2D axis.\n\t * @param block - The block to get bounds for\n\t */\n\tgetBounds(block: IsoBlock): Bounds {\n\t\tlet { x, y, z } = block.position\n\n\t\tconst { x: sx, y: sy, z: sz } = block.size\n\t\treturn {\n\t\t\tminX: x,\n\t\t\tmaxX: x + sx,\n\t\t\tminY: y,\n\t\t\tmaxY: y + sy,\n\t\t\tminZ: z,\n\t\t\tmaxZ: z + sz,\n\t\t}\n\t}\n\n\t/**\n\t *  For the given block, get the min and max values on each isometric axis.\n\t * @param block - The block to get isometric bounds for\n\t */\n\tgetIsoBounds(block: IsoBlock): IsoBounds {\n\t\tconst { frontDown, backUp, leftDown, rightDown } = this.getIsoVerts(block)\n\n\t\treturn {\n\t\t\tminX: frontDown.x,\n\t\t\tmaxX: backUp.x,\n\t\t\tminY: frontDown.y,\n\t\t\tmaxY: backUp.y,\n\t\t\tminH: leftDown.h,\n\t\t\tmaxH: rightDown.h,\n\t\t} as IsoBounds\n\t}\n\n\t/**\n\t * Get a block's vertices with helpful aliases. Each vertex is named from its apparent position\n\t * @param block - The block to measure\n\t * @returns The vertices as a 3D point\n\t */\n\tgetIsoNamedSpaceVerts(block: IsoBlock): Verts {\n\t\tlet { x, y, z } = block.position\n\t\tconst { x: sx, y: sy, z: sz } = block.size\n\n\t\treturn {\n\t\t\trightDown: { x: x + sx, y: y, z: z },\n\t\t\tleftDown: { x: x, y: y + sy, z: z },\n\t\t\tbackDown: { x: x + sx, y: y + sy, z: z },\n\t\t\tfrontDown: { x: x, y: y, z: z },\n\t\t\trightUp: { x: x + sx, y: y, z: z + sz },\n\t\t\tleftUp: { x: x, y: y + sy, z: z + sz },\n\t\t\tbackUp: { x: x + sx, y: y + sy, z: z + sz },\n\t\t\tfrontUp: { x: x, y: y, z: z + sz },\n\t\t}\n\t}\n\n\t/**\n\t * Get the given block's vertices in flattened 2D isometric coordinates.\n\t * @param block - The block to measure\n\t * @returns The isometric vertices as isometric points\n\t */\n\tgetIsoVerts(block: IsoBlock): IsoVerts {\n\t\tconst verts = this.getIsoNamedSpaceVerts(block)\n\t\treturn Object.keys(verts).reduce(\n\t\t\t(acc: IsoVerts, cur: string) => {\n\t\t\t\tacc[cur as Vertice] = this.spaceToIso(verts[cur as Vertice])\n\t\t\t\treturn acc\n\t\t\t},\n\t\t\t{} as IsoVerts\n\t\t)\n\t}\n\n\t/**\n\t * Get a block's vertices with helpful aliases. * Each vertex is named from its apparent position in an isometric view.\n\t * @param block - The block to measure\n\t * @returns The screen vertices as 2D points\n\t */\n\tgetScreenVerts(block: IsoBlock): ScreenVerts {\n\t\tconst verts = this.getIsoNamedSpaceVerts(block)\n\t\treturn Object.keys(verts).reduce(\n\t\t\t(acc: ScreenVerts, cur: string) => {\n\t\t\t\tacc[cur as Vertice] = this.spaceToScreen(verts[cur as Vertice])\n\t\t\t\treturn acc\n\t\t\t},\n\t\t\t{} as ScreenVerts\n\t\t)\n\t}\n\n\t/**\n\t * \tDetermine if the given ranges a and b are disjoint (i.e. do not overlap). For determining drawing order, this camera considers two ranges to be disjoint even if they share an endpoint. Thus, we use less-or-equal (<=) instead of strictly less (<).\n\t * @param amin - The minimum of range a\n\t * @param amax - The maximum of range a\n\t * @param bmin - The minimum of range b\n\t * @param bmax - The maximum of range b\n\t * @returns True if the ranges are disjoint, or false if they overlap\n\t */\n\tareRangesDisjoint(\n\t\tamin: number,\n\t\tamax: number,\n\t\tbmin: number,\n\t\tbmax: number\n\t): boolean {\n\t\treturn amax <= bmin || bmax <= amin\n\t}\n\n\t/**\n\t *If no isometric separation axis is found, then the two blocks do not overlap on the screen.\n\t * @param block_a - The first block to compare\n\t * @param block_b - The second block to compare\n\t * @returns True if the two blocks overlap on screen, or false if they do not\n\t */\n\tdoBlocksOverlap(block_a: IsoBlock, block_b: IsoBlock): boolean {\n\t\treturn this.getIsoSepAxis(block_a, block_b) !== null\n\t}\n\n\t/**\n\t *If no 3D separation axis is found, then the two blocks intersect in 3D space.\n\t * @param block_a - The first block to compare\n\t * @param block_b - The second block to compare\n\t * @returns True if the two blocks intersect in 3D space, or false if they do not\n\t */\n\tdoBlocksIntersect(block_a: IsoBlock, block_b: IsoBlock): boolean {\n\t\treturn this.getSpaceSepAxis(block_a, block_b) === null\n\t}\n\n\t/**\n\t * \tConvert 3D space coordinates to flattened 2D isometric coordinates. x and y coordinates are oblique axes separated by 120 degrees. h,v are the horizontal and vertical distances from the origin.\n\t * @param block_a\n\t * @param block_b\n\t * @returns The axis of separation on the screen, if any\n\t */\n\tgetSpaceSepAxis(block_a: IsoBlock, block_b: IsoBlock): SeparationAxis | null {\n\t\tvar a = this.getBounds(block_a)\n\t\tvar b = this.getBounds(block_b)\n\n\t\tif (this.areRangesDisjoint(a.minX, a.maxX, b.minX, b.maxX)) {\n\t\t\treturn 'x'\n\t\t} else if (this.areRangesDisjoint(a.minY, a.maxY, b.minY, b.maxY)) {\n\t\t\treturn 'y'\n\t\t} else if (this.areRangesDisjoint(a.minZ, a.maxZ, b.minZ, b.maxZ)) {\n\t\t\treturn 'z'\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\t/**\n\t * Try to find an axis in 2D isometric that separates the two given blocks. This helps identify if the the two blocks are overlap on the screen.\n\t * @param block_a - The first block to compare\n\t * @param block_b - The second block to compare\n\t * @returns The axis of separation in isometric space, if any\n\t */\n\tgetIsoSepAxis(\n\t\tblock_a: IsoBlock,\n\t\tblock_b: IsoBlock\n\t): IsoSeparationAxis | null {\n\t\tvar a = this.getIsoBounds(block_a)\n\t\tvar b = this.getIsoBounds(block_b)\n\n\t\tif (this.areRangesDisjoint(a.minX, a.maxX, b.minX, b.maxX)) {\n\t\t\treturn 'x'\n\t\t} else if (this.areRangesDisjoint(a.minY, a.maxY, b.minY, b.maxY)) {\n\t\t\treturn 'y'\n\t\t} else if (this.areRangesDisjoint(a.minH, a.maxH, b.minH, b.maxH)) {\n\t\t\treturn 'h'\n\t\t} else {\n\t\t\treturn null\n\t\t}\n\t}\n\n\t/**\n\t * In an isometric perspective of the two given blocks, determine if they will overlap each other on the screen. If they do, then return\n\t * @param block_a - The first block to compare\n\t * @param block_b - The second block to compare\n\t * @returns The block in front\n\t */\n\tgetFrontBlock(block_a: IsoBlock, block_b: IsoBlock): IsoBlock | null {\n\t\t// If no isometric separation axis is found, then the two blocks do not overlap on the screen. This means there is no \"front\" block to identify.\n\t\tif (!this.getSpaceSepAxis(block_a, block_b)) return null\n\n\t\t// Find a 3D separation axis, and use it to determine which block is in front of the other.\n\t\tconst [a, b] = [this.getBounds(block_a), this.getBounds(block_b)]\n\n\t\tswitch (this.getSpaceSepAxis(block_a, block_b)) {\n\t\t\tcase 'x':\n\t\t\t\treturn a.minX < b.minX ? block_a : block_b\n\t\t\tcase 'y':\n\t\t\t\treturn a.minY < b.minY ? block_a : block_b\n\t\t\tcase 'z':\n\t\t\t\treturn a.minZ < b.minZ ? block_b : block_a\n\t\t\tdefault:\n\t\t\t\tthrow 'Blocks must be non-intersecting!'\n\t\t}\n\t}\n}\n","import { Point } from './index'\nimport { chunk } from 'lodash'\n\n// Helpers\n\nexport function range(num: number) {\n\treturn [...Array(num)].map((_, i) => i)\n}\n\nexport function pull(array: any[], element: any) {\n\tarray.splice(array.indexOf(element), 1)\n}\n\nexport function toPoint(point: Point) {\n\treturn `${point.x},${point.y} `\n}\n\nexport function toPathData(points: Point[], close = true) {\n\treturn `M ${toPoint(points[0])} L ${points.slice(1).map((p) => toPoint(p))} ${\n\t\tclose ? 'Z' : ''\n\t}`\n}\n\nexport function groupBy(xs: any[], key: string) {\n\treturn xs.reduce(function(rv, x) {\n\t\t;(rv[x[key]] = rv[x[key]] || []).push(x)\n\t\treturn rv\n\t}, {})\n}\n\nexport function rotate<T>(array: T[], length: number) {\n\tconst matrix = chunk(array, length)\n\tconst n = length\n\tconst x = Math.floor(n / 2)\n\tconst y = n - 1\n\n\tfor (let i = 0; i < x; i++) {\n\t\tfor (let j = i; j < y - i; j++) {\n\t\t\tlet k = matrix[i][j]\n\t\t\tmatrix[i][j] = matrix[y - j][i]\n\t\t\tmatrix[y - j][i] = matrix[y - i][y - j]\n\t\t\tmatrix[y - i][y - j] = matrix[j][y - i]\n\t\t\tmatrix[j][y - i] = k\n\t\t}\n\t}\n\n\treturn matrix.flat()\n}\n","import { decorate, observable, action } from 'mobx'\n\nimport IsoWorld, { Block } from '../IsoWorld'\nimport { range } from '../IsoWorld/utils'\n\ndecorate(IsoWorld, {\n\t// blocks: observable,\n\tsorted: observable,\n\taddBlocks: action,\n\thovered: observable,\n\tcursor: observable,\n\tsetHovered: action,\n\tmoveBlock: action,\n\tselected: observable,\n\tsort: action,\n})\n\ndecorate(Block, {\n\tposition: observable,\n\tsize: observable,\n\tsilhouette: observable,\n\tfaces: observable,\n\tmoveTo: action.bound,\n\tresizeTo: action.bound,\n})\n\nlet blocks\n\nblocks = []\n\nblocks = range(10)\n\t.map((y) =>\n\t\trange(10).map(\n\t\t\t(x) =>\n\t\t\t\tnew Block(\n\t\t\t\t\t{ x, y, z: 0 },\n\t\t\t\t\t{ x: 1, y: 1, z: 1 } //Math.ceil(Math.random() * 5) }\n\t\t\t\t)\n\t\t)\n\t)\n\t.flat()\n\nblocks.push(new Block({ x: 5, y: 5, z: 1 }, { x: 1, y: 1, z: 1 }))\n\nconst player = new Block(\n\t{ x: 0.25, y: 0.25, z: 1 },\n\t{ x: 0.5, y: 0.5, z: 1.6 },\n\t{ color: 'yellow' }\n)\n\nblocks.push(player)\n\nconst iso = new IsoWorld({\n\theight: 600,\n\twidth: 400,\n\tscale: 20,\n\torigin: (h, w) => ({ x: w / 2, y: h * 0.75 }),\n\tblocks: blocks,\n})\n\niso.selected = player\n\nexport default iso\nexport { Block, IsoWorld }\n","import { range, pull } from './utils'\nimport { maxBy, sortBy } from 'lodash'\nimport anime from 'animejs'\nimport { decorate, action, observable } from 'mobx'\n\nimport {\n\tBlock,\n\tPoint,\n\tIsoPoint,\n\tPoint3,\n\tPainter,\n\tIsoBlock,\n\tCamera,\n\tOrigin,\n} from './index'\n\ninterface IsoParams {\n\twidth: number\n\theight: number\n\tblocks?: Block[]\n\tscale?: number\n\torigin?: Origin\n}\n\nconst defaults = {\n\torigin: (width: number, height: number) => ({\n\t\tx: width / 2,\n\t\ty: height / 2,\n\t}),\n\tscale: 32,\n\tblocks: [],\n}\n\nexport class IsoWorld {\n\tblocks: Block[]\n\tsorted: Block[] = []\n\tcamera: Camera\n\tpainter: Painter\n\thovered?: Block\n\tselected?: Block\n\tcursor?: Block\n\n\tconstructor(params: IsoParams = {} as IsoParams) {\n\t\tconst {\n\t\t\theight,\n\t\t\twidth,\n\t\t\torigin = defaults.origin,\n\t\t\tscale = defaults.scale,\n\t\t\tblocks = defaults.blocks,\n\t\t} = params\n\t\tthis.camera = new Camera(origin(height, width), scale)\n\t\tthis.painter = new Painter(this.camera)\n\t\tthis.blocks = blocks\n\t\tthis.sort()\n\t\tthis.render()\n\t}\n\n\tsort() {\n\t\tthis.sorted = this.getSorted()\n\t}\n\n\t/**\n\t * Get the depth-sorted state of the current blocks\n\t * @return The sorted blocks array\n\t */\n\tgetSorted(): IsoBlock[] {\n\t\treturn this.sortBlocks(this.blocks)\n\t}\n\n\t/**\n\t * Set (or clear) the isoWorld's hovered block\n\t * @param block - The block (or lack of block) to hover\n\t */\n\tsetHovered = (block?: Block) => {\n\t\tthis.hovered = block\n\t}\n\n\t/**\n\t * Animate a block's size or position\n\t * @param block - The block to animate\n\t * @param property - The property to animate\n\t * @param value - A 3D point to animate to\n\t * @param duration - The animation's duration\n\t */\n\tanimateBlock = (\n\t\tblock: IsoBlock,\n\t\tproperty: 'size' | 'position',\n\t\tvalue: Point3,\n\t\tduration = 360\n\t) => {\n\t\tif (block.busy) return\n\t\tblock.busy = true\n\n\t\tanime({\n\t\t\ttargets: block[property],\n\t\t\teasing: 'easeOutQuad',\n\t\t\tduration,\n\t\t\tupdate: () => {\n\t\t\t\tthis.renderBlock(block)\n\t\t\t\tthis.sort()\n\t\t\t},\n\t\t\tcomplete: () => {\n\t\t\t\tblock.busy = false\n\t\t\t\t// this.sort()\n\t\t\t},\n\t\t\t...value,\n\t\t})\n\t}\n\n\tmoveBlock = (\n\t\tblock: IsoBlock,\n\t\tdirection: 'north' | 'east' | 'south' | 'west'\n\t) => {\n\t\tconst { x, y, z } = block.position\n\t\tlet next: Point3\n\n\t\tswitch (direction) {\n\t\t\tcase 'north':\n\t\t\t\tnext = { x: x + 1, y, z }\n\t\t\t\tbreak\n\t\t\tcase 'east':\n\t\t\t\tnext = { x, y: y - 1, z }\n\t\t\t\tbreak\n\t\t\tcase 'south':\n\t\t\t\tnext = { x: x - 1, y, z }\n\t\t\t\tbreak\n\t\t\tcase 'west':\n\t\t\t\tnext = { x, y: y + 1, z }\n\t\t\t\tbreak\n\t\t\tdefault:\n\t\t\t\tnext = { x, y, z }\n\t\t}\n\n\t\tconst nextBlocks = this.getBlocks(next)\n\t\tconst maxZ = maxBy(nextBlocks, (b) => b.position.z)\n\t\tif (!maxZ) return\n\t\tnext.z = maxZ.position.z + maxZ.size.z\n\n\t\tthis.animateBlock(block, 'position', next)\n\t}\n\n\t/**\n\t * Render a block's faces, edges, and other points\n\t * @param block - The block to render\n\t */\n\trenderBlock: (block: IsoBlock) => IsoBlock = (block) => {\n\t\tObject.assign(block, {\n\t\t\tedge: this.painter.getEdge(block),\n\t\t\tfaces: this.painter.getFaces(block),\n\t\t\tsilhouette: this.painter.getSilhouette(block),\n\t\t\toutline: this.painter.getOutline(block),\n\t\t})\n\n\t\treturn block\n\t}\n\n\t/**\n\t * Sort and render all blocks\n\t */\n\trender: () => IsoBlock[] = () => {\n\t\tconst sorted = this.sortBlocks(this.blocks)\n\t\treturn sorted.map(this.renderBlock)\n\t}\n\n\t/**\n\t * Add a block to this IsoWorld\n\t * @param blocks - The block or blocks to add\n\t * @return The new blocks array\n\t */\n\taddBlocks(blocks: IsoBlock | IsoBlock[]): IsoBlock[] {\n\t\tArray.isArray(blocks)\n\t\t\t? (this.blocks = this.blocks.concat(blocks))\n\t\t\t: (this.blocks = [...this.blocks, blocks])\n\n\t\tthis.render()\n\t\treturn this.blocks\n\t}\n\n\t/**\n\t * Remove a block from this IsoWorld\n\t * @param block - The block to remove\n\t * @return The new blocks array\n\t */\n\tremoveBlock(blocks: IsoBlock | IsoBlock[]): IsoBlock[] {\n\t\tif (Array.isArray(blocks)) {\n\t\t\tfor (let block of blocks) {\n\t\t\t\tpull(this.blocks, block)\n\t\t\t}\n\t\t} else {\n\t\t\tpull(this.blocks, blocks)\n\t\t}\n\n\t\treturn this.blocks\n\t}\n\n\t/**\n\t *  Sort blocks in the order that they should be drawn for the given camera.\n\t * @param blocks - The blocks to sort\n\t */\n\tsortBlocks(blocks: Block[]): Block[] {\n\t\tvar i: number,\n\t\t\tj: number,\n\t\t\tnumBlocks = blocks.length\n\n\t\t// Initialize the list of blocks that each block is behind.\n\t\tfor (i = 0; i < numBlocks; i++) {\n\t\t\tblocks[i].blocksBehind = []\n\t\t\tblocks[i].blocksInFront = []\n\t\t}\n\n\t\t// For each pair of blocks, determine which is in front and behind.\n\t\tvar a: Block, b: Block, frontBlock: Block | null\n\t\tfor (i = 0; i < numBlocks; i++) {\n\t\t\ta = blocks[i]\n\n\t\t\tfor (j = i + 1; j < numBlocks; j++) {\n\t\t\t\tb = blocks[j]\n\t\t\t\tfrontBlock = this.camera.getFrontBlock(a, b)\n\t\t\t\tif (frontBlock) {\n\t\t\t\t\tif (a === frontBlock) {\n\t\t\t\t\t\ta.blocksBehind.push(b)\n\t\t\t\t\t\tb.blocksInFront.push(a)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb.blocksBehind.push(a)\n\t\t\t\t\t\ta.blocksInFront.push(b)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Get list of blocks we can safely draw right now.\n\t\t// These are the blocks with nothing behind them.\n\t\tvar blocksToDraw: Block[] = []\n\t\tfor (i = 0; i < numBlocks; i++) {\n\t\t\tif (blocks[i].blocksBehind.length === 0) {\n\t\t\t\tblocksToDraw.push(blocks[i])\n\t\t\t}\n\t\t}\n\n\t\t// While there are still blocks we can draw...\n\t\tvar blocksDrawn: Block[] = []\n\t\twhile (blocksToDraw.length > 0) {\n\t\t\t// Draw block by removing one from \"to draw\" and adding\n\t\t\t// it to the end of our \"drawn\" list.\n\t\t\tvar block = blocksToDraw.pop()\n\t\t\tif (!block) return blocksDrawn\n\t\t\tblocksDrawn.push(block)\n\n\t\t\t// Tell blocks in front of the one we just drew\n\t\t\t// that they can stop waiting on it.\n\t\t\tfor (j = 0; j < block.blocksInFront.length; j++) {\n\t\t\t\tlet front = block.blocksInFront[j]\n\n\t\t\t\t// Add this front block to our \"to draw\" list if there's\n\t\t\t\t// nothing else behind it waiting to be drawn.\n\t\t\t\tpull(front.blocksBehind, block)\n\t\t\t\tif (front.blocksBehind.length === 0) {\n\t\t\t\t\tblocksToDraw.push(front)\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// Determine whether block is an outside edge\n\t\tblocksDrawn.forEach((block) => {\n\t\t\tblock.adjacent = this.getAdjacentBlocks(block)\n\t\t})\n\n\t\treturn blocksDrawn\n\t}\n\n\t// hitTest = (point: Point) => {\n\t// \tconst ccw = (A: number[], B: number[], C: number[]) =>\n\t// \t\t(C[1] - A[1]) * (B[0] - A[0]) > (B[1] - A[1]) * (C[0] - A[0])\n\n\t// \tconst intersect = (A: number[], B: number[], C: number[], D: number[]) =>\n\t// \t\tccw(A, C, D) !== ccw(B, C, D) && ccw(A, B, C) !== ccw(A, B, D)\n\n\t// \tconst hitTestBlock = (point: Point, block: Block) => {\n\t// \t\tconst vs = Object.values(this.camera.getScreenVerts(block))\n\t// \t\tconst points = vs.map((p) => [p.x, p.y])\n\n\t// \t\tlet inside = false\n\t// \t\tlet i = 0\n\t// \t\tlet j = vs.length - 1\n\n\t// \t\twhile (i < points.length) {\n\t// \t\t\tif (intersect([0, point.y], [point.x, point.y], points[i], points[j])) {\n\t// \t\t\t\tinside = !inside\n\t// \t\t\t}\n\t// \t\t\tj = i++\n\t// \t\t}\n\t// \t\treturn inside\n\t// \t}\n\n\t// \treturn this.blocks.find((block) => hitTestBlock(point, block))\n\t// }\n\n\tgetBlockAtIso = (point: Point3) => {\n\t\tlet { x, y, z } = point\n\t\tx = Math.floor(x)\n\t\ty = Math.floor(y)\n\t\tz = Math.floor(z)\n\n\t\treturn this.blocks.find((block) => {\n\t\t\tconst { x: px, y: py, z: pz } = block.position\n\n\t\t\treturn x === px && y === py && z === pz\n\t\t})\n\t}\n\n\tgetBlocks = (point: Point3) => {\n\t\tlet { x, y, z } = point\n\t\tx = Math.floor(x)\n\t\ty = Math.floor(y)\n\t\tz = Math.floor(z)\n\n\t\treturn sortBy(\n\t\t\tthis.blocks.filter((block) => {\n\t\t\t\tconst { x: px, y: py } = block.position\n\n\t\t\t\treturn x === px && y === py\n\t\t\t}),\n\t\t\t'position.z'\n\t\t)\n\t}\n\n\t/**\n\t * Set the isoworld's cursor\n\t * @param point - The 3D space point of the cursor\n\t */\n\tsetCursor = (point: Point3 | null, shape = { x: 1, y: 1, z: 1 }) => {\n\t\tif (!point) {\n\t\t\tthis.cursor = undefined\n\t\t\treturn\n\t\t}\n\n\t\tthis.cursor = new Block(point, shape)\n\t\tthis.renderBlock(this.cursor)\n\t}\n\n\tgetAdjacentBlocks(block: IsoBlock) {\n\t\tconst { x, y, z } = block.position\n\n\t\treturn {\n\t\t\tnorth: this.getBlockAtIso({ x: x + 1, y, z }),\n\t\t\twest: this.getBlockAtIso({ x, y: y + 1, z }),\n\t\t\tabove: this.getBlockAtIso({ x, y, z: z + 1 }),\n\t\t\tsouth: this.getBlockAtIso({ x: x - 1, y, z }),\n\t\t\teast: this.getBlockAtIso({ x, y: y - 1, z }),\n\t\t\tbelow: this.getBlockAtIso({ x, y, z: z - 1 }),\n\t\t}\n\t}\n}\n","import { Camera } from './Camera'\nimport { toPathData } from './utils'\nimport { IsoBlock } from './index'\n\nexport class Painter {\n\tcamera: Camera\n\n\tconstructor(camera: Camera) {\n\t\tthis.camera = camera\n\t}\n\n\tgetEdge(block: IsoBlock): string {\n\t\tconst v = this.camera.getScreenVerts(block)\n\t\tconst { north, east, south, west, above, below } = block.adjacent\n\n\t\tlet l = ''\n\t\tlet r = ''\n\n\t\tif (!north && !above) r += toPathData([v.backUp, v.rightUp], false)\n\t\tif (!north && !east) r += toPathData([v.rightUp, v.rightDown], false)\n\t\tif (!east && !below) r += toPathData([v.rightDown, v.frontDown], false)\n\n\t\tif (!west && !above) l += toPathData([v.backUp, v.leftUp], false)\n\t\tif (!west && !south) l += toPathData([v.leftUp, v.leftDown], false)\n\t\tif (!south && !below) l += toPathData([v.leftDown, v.frontDown], false)\n\n\t\treturn l + r\n\t}\n\n\tgetSilhouette(block: IsoBlock): string {\n\t\tconst v = this.camera.getScreenVerts(block)\n\t\treturn toPathData([\n\t\t\tv.frontDown,\n\t\t\tv.leftDown,\n\t\t\tv.leftUp,\n\t\t\tv.backUp,\n\t\t\tv.rightUp,\n\t\t\tv.rightDown,\n\t\t])\n\t}\n\n\tgetFaces(block: IsoBlock): string[] {\n\t\tconst v = this.camera.getScreenVerts(block)\n\n\t\treturn [\n\t\t\t[v.frontUp, v.leftUp, v.backUp, v.rightUp],\n\t\t\t[v.frontDown, v.leftDown, v.leftUp, v.frontUp],\n\t\t\t[v.frontDown, v.rightDown, v.rightUp, v.frontUp],\n\t\t].map((face) => toPathData(face))\n\t}\n\n\tgetOutline(block: IsoBlock): string {\n\t\tconst v = this.camera.getScreenVerts(block)\n\n\t\treturn (\n\t\t\ttoPathData([\n\t\t\t\tv.frontDown,\n\t\t\t\tv.leftDown,\n\t\t\t\tv.leftUp,\n\t\t\t\tv.backUp,\n\t\t\t\tv.rightUp,\n\t\t\t\tv.rightDown,\n\t\t\t]) +\n\t\t\ttoPathData([v.frontUp, v.frontDown]) +\n\t\t\ttoPathData([v.frontUp, v.leftUp]) +\n\t\t\ttoPathData([v.frontUp, v.rightUp])\n\t\t)\n\t}\n}\n","import { Block } from './Block'\nimport { Camera } from './Camera'\nimport { IsoWorld } from './IsoWorld'\nimport { Painter } from './Painter'\n\nexport type Origin = (width: number, height: number) => Point\n\nexport type SeparationAxis = 'x' | 'y' | 'z'\nexport type IsoSeparationAxis = 'x' | 'y' | 'h'\n\nexport interface Point {\n\tx: number\n\ty: number\n}\n\nexport interface Point3 {\n\tx: number\n\ty: number\n\tz: number\n}\n\nexport interface IsoPoint {\n\tx: number\n\ty: number\n\th: number\n\tv: number\n}\n\nexport interface Bounds {\n\tminX: number\n\tmaxX: number\n\tminY: number\n\tmaxY: number\n\tminZ: number\n\tmaxZ: number\n}\n\nexport interface IsoBounds {\n\tminX: number\n\tmaxX: number\n\tminY: number\n\tmaxY: number\n\tminH: number\n\tmaxH: number\n}\n\nexport interface Verts {\n\trightDown: Point3\n\tleftDown: Point3\n\tbackDown: Point3\n\tfrontDown: Point3\n\trightUp: Point3\n\tleftUp: Point3\n\tbackUp: Point3\n\tfrontUp: Point3\n}\n\nexport type IsoVerts = {\n\trightDown: IsoPoint\n\tleftDown: IsoPoint\n\tbackDown: IsoPoint\n\tfrontDown: IsoPoint\n\trightUp: IsoPoint\n\tleftUp: IsoPoint\n\tbackUp: IsoPoint\n\tfrontUp: IsoPoint\n}\n\nexport type ScreenVerts = {\n\trightDown: Point\n\tleftDown: Point\n\tbackDown: Point\n\tfrontDown: Point\n\trightUp: Point\n\tleftUp: Point\n\tbackUp: Point\n\tfrontUp: Point\n}\n\nexport type Vertice = keyof Verts\n\nexport type IsoBlock = Block\n\nexport interface AdjacentBlocks {\n\tnorth?: Block\n\teast?: Block\n\tsouth?: Block\n\twest?: Block\n\tabove?: Block\n\tbelow?: Block\n}\n\nexport { Block, Painter, Camera }\n\nexport default IsoWorld\n","import React, { Component } from 'react'\nimport { Block, Point3, Point } from '../IsoWorld'\nimport { observer } from 'mobx-react'\nimport CubeSprite from './sprites/cube.png'\n\ninterface BlockProps {\n\tblock: Block\n\tpoint: Point\n\tonMouseEnter?: (block: Block) => void\n\tonClick?: (block: Block) => void\n}\nlet i = 0\n\nconst colors = {\n\tgrey: ['#AAA', '#888', '#777', '#444', '#222'],\n\tyellow: ['#FFA', '#FD8', '#FA7', '#F74', '#F32'],\n}\n\nclass SVGBlock extends Component<BlockProps> {\n\trender() {\n\t\tconst { block, point, onMouseEnter, onClick } = this.props\n\n\t\tconst { color, faces, edge, silhouette } = block\n\n\t\tconst key = `${block.position.x}_${block.position.y}_${block.position.z}`\n\n\t\tconst selectedColor = colors[color as 'grey' | 'yellow']\n\n\t\treturn (\n\t\t\t<g\n\t\t\t\tonMouseEnter={\n\t\t\t\t\tonMouseEnter\n\t\t\t\t\t\t? (ev) => {\n\t\t\t\t\t\t\t\tonMouseEnter(block)\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t: undefined\n\t\t\t\t}\n\t\t\t\tonClick={onClick ? () => onClick(block) : undefined}\n\t\t\t>\n\t\t\t\t{faces.map((face, faceIndex) => {\n\t\t\t\t\tlet fill = selectedColor[faceIndex]\n\n\t\t\t\t\treturn (\n\t\t\t\t\t\t<path\n\t\t\t\t\t\t\tkey={`block_${key}_face_${faceIndex}`}\n\t\t\t\t\t\t\td={face}\n\t\t\t\t\t\t\tstroke=\"none\"\n\t\t\t\t\t\t\tfill={fill}\n\t\t\t\t\t\t\tstrokeWidth=\"1\"\n\t\t\t\t\t\t/>\n\t\t\t\t\t)\n\t\t\t\t})}\n\t\t\t\t{edge && (\n\t\t\t\t\t<path\n\t\t\t\t\t\td={edge}\n\t\t\t\t\t\tstroke={selectedColor[4]}\n\t\t\t\t\t\tfill=\"none\"\n\t\t\t\t\t\tstrokeWidth={0.5}\n\t\t\t\t\t/>\n\t\t\t\t)}\n\t\t\t\t{/* <image\n\t\t\t\t\tx={point.x - 20}\n\t\t\t\t\ty={point.y - 40}\n\t\t\t\t\twidth={42}\n\t\t\t\t\theight={42}\n\t\t\t\t\txlinkHref={CubeSprite}\n\t\t\t\t\topacity={1}\n\t\t\t\t/> */}\n\t\t\t</g>\n\t\t)\n\t}\n}\n\nexport default observer(SVGBlock)\n","import React, { Component } from 'react'\nimport IsoWorld, { Block, Point3 } from '../IsoWorld'\nimport { observer } from 'mobx-react'\n\ninterface BlockProps {\n\tiso: IsoWorld\n}\n\nclass HoveredIndicator extends Component<BlockProps> {\n\trender() {\n\t\tconst { cursor } = this.props.iso\n\n\t\tif (!cursor) return <g />\n\n\t\tconst { silhouette } = cursor\n\n\t\treturn (\n\t\t\t<g pointerEvents={'none'}>\n\t\t\t\t<path d={silhouette} stroke=\"none\" fill=\"rgba(109, 223, 255, .5)\" />\n\t\t\t</g>\n\t\t)\n\t}\n}\n\nexport default observer(HoveredIndicator)\n","import React, { Component } from 'react'\nimport IsoWorld, { Block, Point3 } from '../IsoWorld'\nimport { observer } from 'mobx-react'\n\ninterface BlockProps {\n\tiso: IsoWorld\n\tzCursor: number\n}\n\nclass ZCursorIndicator extends Component<BlockProps> {\n\trender() {\n\t\tconst { iso, zCursor } = this.props\n\t\tconst { scale, origin } = iso.camera\n\t\tconst { x, y } = origin\n\n\t\treturn (\n\t\t\t<g\n\t\t\t\ttransform={`translate(${x}, ${y - zCursor * scale})`}\n\t\t\t\tpointerEvents={'none'}\n\t\t\t>\n\t\t\t\t<path\n\t\t\t\t\td={`M -8,8 L 8,8 0,0`}\n\t\t\t\t\tstroke=\"none\"\n\t\t\t\t\tfill=\"rgba(109, 223, 255, .5)\"\n\t\t\t\t/>\n\t\t\t\t<text\n\t\t\t\t\tx={0}\n\t\t\t\t\ty={24}\n\t\t\t\t\ttextAnchor={'middle'}\n\t\t\t\t\tfontSize={12}\n\t\t\t\t\tfontWeight=\"bold\"\n\t\t\t\t\tfill=\"rgba(109, 223, 255, .5)\"\n\t\t\t\t>\n\t\t\t\t\t{zCursor}\n\t\t\t\t</text>\n\t\t\t</g>\n\t\t)\n\t}\n}\n\nexport default observer(ZCursorIndicator)\n","import React, { Component } from 'react'\nimport './App.css'\n\nimport { observer } from 'mobx-react'\nimport { decorate, observe, observable, action } from 'mobx'\n\nimport IsoWorld, { Block, IsoPoint, Point } from './IsoWorld'\nimport { range, groupBy, rotate } from './IsoWorld/utils'\n\nimport SVGBlock from './components/SVGBlock'\nimport IsoSprite from './components/IsoSprite'\nimport HoveredIndicator from './components/HoveredIndicator'\nimport ZCursorIndicator from './components/ZCursorIndicator'\n\nimport iso from './state'\n\nlet i = 0\n\ninterface Props {\n\tiso: IsoWorld\n}\n\nclass App extends Component<Props> {\n\tcontainer: React.RefObject<HTMLDivElement> = React.createRef()\n\tmousePoint: Point = { x: 0, y: 0 }\n\n\tstatic defaultProps = {\n\t\tiso,\n\t}\n\n\tstate = {\n\t\tshowCursor: false,\n\t\tzCursor: 0,\n\t\tblocks: [] as Block[],\n\t}\n\n\tpointToIso(point: Point, floor = true) {\n\t\tconst container = this.container.current\n\t\tconst { iso } = this.props\n\n\t\tif (!container) return\n\n\t\tconst point3 = {\n\t\t\tx: point.x - container.offsetLeft,\n\t\t\ty: point.y - container.offsetTop,\n\t\t\tz: this.state.zCursor,\n\t\t}\n\n\t\treturn iso.camera.screenToIso(point3, floor)\n\t}\n\n\tcomponentWillMount() {\n\t\t// const { iso } = this.props\n\n\t\t// this.setState({\n\t\t// \tblocks: iso.render(),\n\t\t// })\n\n\t\t// observe(iso, (change) => {\n\t\t// \tconsole.log(change)\n\t\t// \tif (change.name === 'blocks') {\n\t\t// \t\tconsole.log('updated')\n\t\t// \t\tthis.setState({\n\t\t// \t\t\tblocks: iso.render(),\n\t\t// \t\t})\n\t\t// \t}\n\t\t// })\n\n\t\twindow.addEventListener('keypress', (event) => {\n\t\t\tconst { zCursor } = this.state\n\t\t\tconst keyHandlers: { [key: string]: any } = {\n\t\t\t\tq: () => this.setState({ zCursor: zCursor - 1 }),\n\t\t\t\te: () => this.setState({ zCursor: zCursor + 1 }),\n\t\t\t\tw: () => iso.selected && iso.moveBlock(iso.selected, 'north'),\n\t\t\t\ts: () => iso.selected && iso.moveBlock(iso.selected, 'south'),\n\t\t\t\ta: () => iso.selected && iso.moveBlock(iso.selected, 'west'),\n\t\t\t\td: () => iso.selected && iso.moveBlock(iso.selected, 'east'),\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tkeyHandlers[event.key]()\n\t\t\t\tthis.setCursor(this.mousePoint, false)\n\t\t\t} catch (e) {}\n\t\t})\n\t}\n\n\tcomponentDidMount() {}\n\n\thandleClick = (event: React.MouseEvent<any, MouseEvent>) => {\n\t\tconst isoPoint = this.pointToIso(this.mousePoint)\n\t\tif (!isoPoint) return\n\n\t\tthis.createBlock(isoPoint)\n\t}\n\n\thandleMouseMove = (event: React.MouseEvent<any, MouseEvent>) => {\n\t\tthis.mousePoint = { x: event.pageX, y: event.pageY }\n\t\tthis.setCursor(this.mousePoint, event.buttons === 1)\n\t}\n\n\tsetCursor = (point: Point, click: boolean) => {\n\t\tconst { showCursor, zCursor } = this.state\n\t\tif (!showCursor) return\n\n\t\tconst isoPoint = this.pointToIso(point)\n\t\tif (!isoPoint) return\n\n\t\tif (click) this.createBlock(isoPoint)\n\n\t\tiso.setCursor({ x: isoPoint.x, y: isoPoint.y, z: zCursor })\n\t}\n\n\tcreateBlock(point: IsoPoint) {\n\t\tconst { x, y } = point\n\t\tconst { zCursor: z } = this.state\n\n\t\tiso.addBlocks(new Block({ x, y, z }, { x: 1, y: 1, z: 1 }))\n\t}\n\n\trender() {\n\t\tconst { iso } = this.props\n\t\tconst { sorted } = iso\n\t\tconst { zCursor, showCursor } = this.state\n\n\t\tlet blocksToShow = { focus: [], lower: [], higher: [] } as {\n\t\t\t[key: string]: Block[]\n\t\t}\n\n\t\t// console.log(sorted)\n\n\t\tif (showCursor) {\n\t\t\tsorted.reduce((acc, cur) => {\n\t\t\t\tif (cur.position.z < zCursor) {\n\t\t\t\t\tacc.lower.push(cur)\n\t\t\t\t} else if (cur.position.z > zCursor) {\n\t\t\t\t\tacc.higher.push(cur)\n\t\t\t\t} else {\n\t\t\t\t\tacc.focus.push(cur)\n\t\t\t\t}\n\t\t\t\treturn acc\n\t\t\t}, blocksToShow)\n\t\t} else {\n\t\t\tblocksToShow.focus = sorted\n\t\t}\n\n\t\treturn (\n\t\t\t<div className=\"App\">\n\t\t\t\t<div\n\t\t\t\t\tref={this.container}\n\t\t\t\t\tstyle={{\n\t\t\t\t\t\tmargin: '0 auto',\n\t\t\t\t\t\theight: 600,\n\t\t\t\t\t\twidth: 400,\n\t\t\t\t\t\tposition: 'relative',\n\t\t\t\t\t\tcursor: 'none',\n\t\t\t\t\t}}\n\t\t\t\t\tonMouseEnter={() => this.setState({ showCursor: true })}\n\t\t\t\t\tonMouseLeave={() =>\n\t\t\t\t\t\tthis.setState({ showCursor: false }, () => iso.setCursor(null))\n\t\t\t\t\t}\n\t\t\t\t>\n\t\t\t\t\t<svg\n\t\t\t\t\t\tviewBox=\"0,0,400,600\"\n\t\t\t\t\t\tstyle={{\n\t\t\t\t\t\t\tposition: 'absolute',\n\t\t\t\t\t\t\tleft: 0,\n\t\t\t\t\t\t\ttop: 0,\n\t\t\t\t\t\t\tborder: '1px solid #000',\n\t\t\t\t\t\t\theight: 600,\n\t\t\t\t\t\t\twidth: 400,\n\t\t\t\t\t\t}}\n\t\t\t\t\t\tonMouseMove={this.handleMouseMove}\n\t\t\t\t\t\tonClick={this.handleClick}\n\t\t\t\t\t>\n\t\t\t\t\t\t<g key={`blocks_z_layer_lower`} opacity={0.45}>\n\t\t\t\t\t\t\t{blocksToShow.lower.map((block, index) => {\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<SVGBlock\n\t\t\t\t\t\t\t\t\t\tkey={`block_${index}`}\n\t\t\t\t\t\t\t\t\t\tblock={block}\n\t\t\t\t\t\t\t\t\t\tpoint={iso.camera.spaceToScreen(block.position)}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</g>\n\t\t\t\t\t\t<g key={`blocks_z_layer_focused`} opacity={1}>\n\t\t\t\t\t\t\t{blocksToShow.focus.map((block, index) => {\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<SVGBlock\n\t\t\t\t\t\t\t\t\t\tkey={`block_${index}`}\n\t\t\t\t\t\t\t\t\t\tblock={block}\n\t\t\t\t\t\t\t\t\t\tpoint={iso.camera.spaceToScreen(block.position)}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</g>\n\t\t\t\t\t\t<g key={`blocks_z_layer_higher`} opacity={0.45}>\n\t\t\t\t\t\t\t{blocksToShow.higher.map((block, index) => {\n\t\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t\t<SVGBlock\n\t\t\t\t\t\t\t\t\t\tkey={`block_${index}`}\n\t\t\t\t\t\t\t\t\t\tblock={block}\n\t\t\t\t\t\t\t\t\t\tpoint={iso.camera.spaceToScreen(block.position)}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t})}\n\t\t\t\t\t\t</g>\n\t\t\t\t\t\t))}\n\t\t\t\t\t\t{showCursor && (\n\t\t\t\t\t\t\t<>\n\t\t\t\t\t\t\t\t<HoveredIndicator iso={iso} />\n\t\t\t\t\t\t\t\t<ZCursorIndicator iso={iso} zCursor={zCursor} />\n\t\t\t\t\t\t\t</>\n\t\t\t\t\t\t)}\n\t\t\t\t\t</svg>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t)\n\t}\n}\n\n// export default App\nexport default observer(App)\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      (process as { env: { [key: string]: string } }).env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './index.css'\nimport App from './App'\nimport * as serviceWorker from './serviceWorker'\n\nReactDOM.render(<App />, document.getElementById('root'))\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister()\n"],"sourceRoot":""}